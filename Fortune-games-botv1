<!DOCTYPE html><html lang="en">
<head>
<meta charset="UTF-8">
<title>Live Game Signals</title>
<style>
  body { background: #0e0e1a; color: #fff; font-family: Arial, sans-serif; text-align: center; }
  h1 { color: #00ff99; margin-top: 20px; }
  #signal { font-size: 40px; margin-top: 20px; }
  #confidence { font-size: 20px; margin-top: 10px; }
  ul { list-style: none; padding: 0; margin-top: 20px; }
  li { font-size: 18px; margin: 5px 0; }
</style>
</head>
<body><h1>ðŸŽ® Live Game Signals</h1>
<div id="signal">-</div>
<div id="confidence">-</div>
<ul id="history"></ul><script>
const signalEl = document.getElementById('signal');
const confEl = document.getElementById('confidence');
const historyEl = document.getElementById('history');

let gameHistory = [];

// Simulate fetching live game result
function fetchGameData() {
    const result = Math.random() < 0.5 ? 'HIGH' : 'LOW';
    gameHistory.push(result);
    if (gameHistory.length > 50) gameHistory.shift();
    return gameHistory;
}

// Analyze pattern & generate signal
function analyzePattern() {
    const history = fetchGameData();
    const highCount = history.filter(r => r === 'HIGH').length;
    const lowCount = history.filter(r => r === 'LOW').length;

    const probHigh = highCount / history.length;
    const probLow = lowCount / history.length;

    const signal = probHigh > probLow ? 'HIGH' : 'LOW';
    const confidence = Math.max(probHigh, probLow);

    // Update dashboard
    signalEl.textContent = signal;
    confEl.textContent = `Confidence: ${(confidence*100).toFixed(1)}%`;

    // Update last 10 game history
    historyEl.innerHTML = '';
    history.slice(-10).reverse().forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        historyEl.appendChild(li);
    });
}

// Run every 3 seconds
setInterval(analyzePattern, 3000);
</script></body>
</html>
}, [last50, mean, std, streak, vol, risk, bankroll]);

// Auto mode: synthesize a pseudo feed from last value to demo behavior useEffect(() => { if (!autoMode) return; const id = setInterval(() => { const base = history[history.length - 1] ?? 50; // pseudo random walk with regime shifts const drift = (Math.random() - 0.5) * (20 + vol * 40); const next = clamp(base + drift, 0, 100); setHistory((h) => [...h.slice(-199), next]); }, 1500); return () => clearInterval(id); }, [autoMode, history, setHistory, vol]);

// Play sound on new actionable signal const prevActionRef = useRef(null); useEffect(() => { if (!signal) return; if (prevActionRef.current !== signal.action) { prevActionRef.current = signal.action; if (sound && audioRef.current) { audioRef.current.currentTime = 0; audioRef.current.play().catch(() => {}); } setLog((L) => [ { t: Date.now(), action: signal.action, confidence: signal.confidence, pct: signal.suggestedPct, ctx: signal.context, mean: Number((mean ?? 0).toFixed(2)), last: Number((latest ?? 0).toFixed(2)), }, ...L, ].slice(0, 200)); } }, [signal, sound, setLog, mean, latest]);

function addEntriesFromText() { const parts = input.split(/[,\n\s]+/).filter(Boolean); const mapped = parts .map((p) => normalizeEntry(p, bucketMap)) .filter((v) => v != null); if (mapped.length) setHistory((h) => [...h.slice(-200 + mapped.length), ...mapped]); setInput(""); }

function addQuick(bucket) { const v = bucketMap[bucket]; if (v != null) setHistory((h) => [...h.slice(-199), v]); }

function resetAll() { if (!confirm("Clear history and logs?")) return; setHistory([]); setLog([]); }

const tip = useMemo(() => { if (!signal) return "Feed at least 8 rounds to start receiving signals."; if (signal.action === "HOLD") return "Market uncertain: reduce size or wait for clearer edge."; if (signal.action.includes("HIGH")) return "Bullish bias detected: trend-follow favored in calm regimes."; return "Bearish bias detected: mean-reversion opportunity in high volatility."; }, [signal]);

return ( <div className="min-h-screen w-full bg-neutral-950 text-neutral-100 p-4 sm:p-6"> <audio ref={audioRef} src={beepData} preload="auto" /> <div className="max-w-6xl mx-auto grid gap-4"> <header className="flex flex-col sm:flex-row sm:items-end sm:justify-between gap-3"> <div> <h1 className="text-2xl sm:text-3xl font-bold tracking-tight">Fortune Gems Signal Bot</h1> <p className="text-sm text-neutral-400 mt-1">Client-side analyzer for practice. Enter recent outcomes as L/M/H or 0â€“100. No hacks, no guarantees.</p> </div> <div className="flex flex-wrap items-center gap-2"> <button onClick={() => setAutoMode((v) => !v)} className={px-3 py-2 rounded-2xl text-sm shadow ${autoMode ? "bg-emerald-600" : "bg-neutral-800"}}>{autoMode ? "Auto: ON" : "Auto: OFF"}</button> <button onClick={resetAll} className="px-3 py-2 rounded-2xl text-sm shadow bg-neutral-800">Reset</button> </div> </header>

{/* Controls */}
    <section className="grid md:grid-cols-3 gap-4">
      <div className="md:col-span-2 bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4 shadow">
        <h2 className="font-semibold mb-2">Add Outcomes</h2>
        <div className="flex flex-wrap gap-2 mb-3">
          {(["L","M","H"]).map((b) => (
            <button key={b} onClick={() => addQuick(b)} className="px-3 py-2 rounded-2xl bg-neutral-800 text-sm shadow">{b}</button>
          ))}
        </div>
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Paste values like: L M H 35 60 80 L H...\n(Separated by space/comma/newline)"
          className="w-full h-28 rounded-xl bg-neutral-800/70 border border-neutral-700 p-3 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-600"
        />
        <div className="mt-2 flex gap-2">
          <button onClick={addEntriesFromText} className="px-3 py-2 rounded-2xl bg-emerald-600 text-sm font-medium shadow">Add</button>
          <button onClick={() => setHistory((h) => h.slice(0, -1))} className="px-3 py-2 rounded-2xl bg-neutral-800 text-sm shadow">Undo</button>
        </div>
      </div>

      <div className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4 shadow">
        <h2 className="font-semibold mb-2">Settings</h2>
        <label className="block text-sm text-neutral-400 mb-1">Bucket map (L/M/H â†’ 0â€“100)</label>
        <div className="grid grid-cols-3 gap-2 mb-3">
          {["L","M","H"].map((k) => (
            <div key={k} className="bg-neutral-800 rounded-xl p-2">
              <div className="text-xs mb-1">{k}</div>
              <input type="number" className="w-full bg-neutral-900 rounded-lg p-2 text-sm"
                value={bucketMap[k]}
                onChange={(e) => setBucketMap({ ...bucketMap, [k]: clamp(Number(e.target.value||0),0,100) })}
              />
            </div>
          ))}
        </div>
        <div className="grid grid-cols-2 gap-3">
          <div>
            <label className="block text-sm text-neutral-400 mb-1">Bankroll</label>
            <input type="number" value={bankroll} onChange={(e)=> setBankroll(Math.max(0, Number(e.target.value||0)))} className="w-full bg-neutral-800 rounded-xl p-2" />
          </div>
          <div>
            <label className="block text-sm text-neutral-400 mb-1">Max % per bet</label>
            <input type="number" value={risk} onChange={(e)=> setRisk(clamp(Number(e.target.value||0), 0.2, 10))} className="w-full bg-neutral-800 rounded-xl p-2" />
          </div>
        </div>
        <div className="mt-3 flex items-center gap-2">
          <input id="sound" type="checkbox" checked={sound} onChange={(e)=> setSound(e.target.checked)} />
          <label htmlFor="sound" className="text-sm">Sound alerts</label>
        </div>
      </div>
    </section>

    {/* Signal Card */}
    <section className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4 shadow">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <div>
          <div className="text-xs uppercase tracking-wide text-neutral-400">Live Signal</div>
          <div className="text-lg sm:text-xl font-bold">{signal ? signal.action : "Waiting for data..."}</div>
        </div>
        <div className="flex gap-3 text-sm">
          <div className="bg-neutral-800 rounded-xl p-2">
            <div className="text-neutral-400 text-xs">Confidence</div>
            <div className="font-semibold">{signal ? signal.confidence + "%" : "â€”"}</div>
          </div>
          <div className="bg-neutral-800 rounded-xl p-2">
            <div className="text-neutral-400 text-xs">Suggest Size</div>
            <div className="font-semibold">{signal ? signal.suggestedPct + "%" : "â€”"}</div>
          </div>
          <div className="bg-neutral-800 rounded-xl p-2">
            <div className="text-neutral-400 text-xs">Session Stop</div>
            <div className="font-semibold">{signal ? signal.stopLossSession : "â€”"}</div>
          </div>
        </div>
      </div>

      <div className="mt-3 text-sm text-neutral-300">{tip}</div>
      <div className="mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2 text-xs text-neutral-400">
        <div className="bg-neutral-800 rounded-xl p-2">Last: <span className="text-neutral-200">{latest ?? "â€”"}</span></div>
        <div className="bg-neutral-800 rounded-xl p-2">Mean: <span className="text-neutral-200">{mean?.toFixed(2) ?? "â€”"}</span></div>
        <div className="bg-neutral-800 rounded-xl p-2">Vol: <span className="text-neutral-200">{vol?.toFixed(2) ?? "â€”"}</span></div>
        <div className="bg-neutral-800 rounded-xl p-2">Z: <span className="text-neutral-200">{signal?.context.z ?? "â€”"}</span></div>
      </div>
    </section>

    {/* Charts (minimal) */}
    <section className="grid md:grid-cols-3 gap-4">
      <div className="md:col-span-2 bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4">
        <h3 className="font-semibold mb-2">Recent History (last {last50.length})</h3>
        <Sparkline data={last50} />
      </div>
      <div className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4">
        <h3 className="font-semibold mb-2">How to Use</h3>
        <ul className="text-sm list-disc pl-5 space-y-2 text-neutral-300">
          <li>Feed your last 20â€“50 round outcomes as L/M/H or 0â€“100 strength.</li>
          <li>Wait for a clear signal (&gt; 60% confidence) before acting.</li>
          <li>Respect the suggested size cap and the session stop.</li>
          <li>For education/testing only. Outcomes are independent; no guaranteed edge.</li>
        </ul>
      </div>
    </section>

    {/* Log */}
    <section className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold">Signal Log</h3>
        <div className="text-xs text-neutral-400">{formatTime()}</div>
      </div>
      <div className="mt-2 max-h-64 overflow-auto rounded-xl border border-neutral-800">
        <table className="w-full text-sm">
          <thead className="bg-neutral-900/80 sticky top-0">
            <tr>
              <th className="text-left p-2">Time</th>
              <th className="text-left p-2">Action</th>
              <th className="text-left p-2">Conf</th>
              <th className="text-left p-2">Size %</th>
              <th className="text-left p-2">Z</th>
              <th className="text-left p-2">Vol</th>
              <th className="text-left p-2">Mean</th>
              <th className="text-left p-2">Last</th>
            </tr>
          </thead>
          <tbody>
            {log.map((row, i) => (
              <tr key={i} className="odd:bg-neutral-900/40">
                <td className="p-2 text-neutral-400">{new Date(row.t).toLocaleTimeString()}</td>
                <td className="p-2 font-semibold">{row.action}</td>
                <td className="p-2">{row.confidence}%</td>
                <td className="p-2">{row.pct}%</td>
                <td className="p-2">{row.ctx.z}</td>
                <td className="p-2">{row.ctx.vol}</td>
                <td className="p-2">{row.mean}</td>
                <td className="p-2">{row.last}</td>
              </tr>
            ))}
            {!log.length && (
              <tr>
                <td className="p-3 text-neutral-400" colSpan={8}>No logs yet.</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </section>

    <footer className="text-center text-xs text-neutral-500 mt-2">
      Built for learning & discipline. Follow game Terms of Service. No affiliation.
    </footer>
  </div>
</div>

); }

function Sparkline({ data = [] }) { const ref = useRef(null); useEffect(() => { const canvas = ref.current; if (!canvas) return; const ctx = canvas.getContext("2d"); const w = canvas.width = canvas.clientWidth * devicePixelRatio; const h = canvas.height = 140 * devicePixelRatio; ctx.clearRect(0,0,w,h); if (!data.length) return; const min = Math.min(...data); const max = Math.max(...data); const pad = 8 * devicePixelRatio; const nx = (i) => pad + (w - pad * 2) * (i / Math.max(1, data.length - 1)); const ny = (v) => h - pad - (h - pad * 2) * ((v - min) / Math.max(1e-6, max - min));

// grid
ctx.globalAlpha = 0.25;
ctx.strokeStyle = "#555";
[0.25, 0.5, 0.75].forEach((p) => {
  const y = pad + (h - pad * 2) * p;
  ctx.beginPath();
  ctx.moveTo(pad, y);
  ctx.lineTo(w - pad, y);
  ctx.stroke();
});
ctx.globalAlpha = 1;

// line
ctx.lineWidth = 2 * devicePixelRatio;
ctx.strokeStyle = "#22c55e"; // emerald
ctx.beginPath();
ctx.moveTo(nx(0), ny(data[0]));
for (let i = 1; i < data.length; i++) ctx.lineTo(nx(i), ny(data[i]));
ctx.stroke();

// last point
const lx = nx(data.length - 1);
const ly = ny(data[data.length - 1]);
ctx.fillStyle = "#e5e7eb";
ctx.beginPath();
ctx.arc(lx, ly, 3 * devicePixelRatio, 0, Math.PI * 2);
ctx.fill();

}, [data]);

return <canvas ref={ref} className="w-full h-[140px]" />; }
// Score: combine momentum (trend) and mean-reversion (z)
const score = followBias * momentum - fadeBias * clamp(z, -2, 2) / 2;

// Map score -> action
let action = "HOLD";
let confidence = 50 + Math.abs(score) * 40; // 50..90
if (score > 0.25) action = "BET HIGH";
else if (score < -0.25) action = "BET LOW";

// Position sizing via Kelly fraction lite based on confidence and vol
const edge = (confidence - 50) / 100; // -0.5..0.4
const kelly = clamp(edge / Math.max(1, vol * 2.5), -0.05, 0.08); // -5%..8%
const suggestedPct = clamp(Math.abs(kelly) * 100, 0.2, risk);
const stop = Math.max(1, bankroll * 0.05); // session stop 5%

return {
  action,
  confidence: Math.round(confidence),
  suggestedPct: Number(suggestedPct.toFixed(2)),
  stopLossSession: Number(stop.toFixed(2)),
  context: { z: Number(z.toFixed(2)), vol: Number(vol.toFixed(2)), momentum: Number(momentum.toFixed(2)) },
};

}, [last50, mean, std, streak, vol, risk, bankroll]);

// Auto mode: synthesize a pseudo feed from last value to demo behavior useEffect(() => { if (!autoMode) return; const id = setInterval(() => { const base = history[history.length - 1] ?? 50; // pseudo random walk with regime shifts const drift = (Math.random() - 0.5) * (20 + vol * 40); const next = clamp(base + drift, 0, 100); setHistory((h) => [...h.slice(-199), next]); }, 1500); return () => clearInterval(id); }, [autoMode, history, setHistory, vol]);

// Play sound on new actionable signal const prevActionRef = useRef(null); useEffect(() => { if (!signal) return; if (prevActionRef.current !== signal.action) { prevActionRef.current = signal.action; if (sound && audioRef.current) { audioRef.current.currentTime = 0; audioRef.current.play().catch(() => {}); } setLog((L) => [ { t: Date.now(), action: signal.action, confidence: signal.confidence, pct: signal.suggestedPct, ctx: signal.context, mean: Number((mean ?? 0).toFixed(2)), last: Number((latest ?? 0).toFixed(2)), }, ...L, ].slice(0, 200)); } }, [signal, sound, setLog, mean, latest]);

function addEntriesFromText() { const parts = input.split(/[,\n\s]+/).filter(Boolean); const mapped = parts .map((p) => normalizeEntry(p, bucketMap)) .filter((v) => v != null); if (mapped.length) setHistory((h) => [...h.slice(-200 + mapped.length), ...mapped]); setInput(""); }

function addQuick(bucket) { const v = bucketMap[bucket]; if (v != null) setHistory((h) => [...h.slice(-199), v]); }

function resetAll() { if (!confirm("Clear history and logs?")) return; setHistory([]); setLog([]); }

const tip = useMemo(() => { if (!signal) return "Feed at least 8 rounds to start receiving signals."; if (signal.action === "HOLD") return "Market uncertain: reduce size or wait for clearer edge."; if (signal.action.includes("HIGH")) return "Bullish bias detected: trend-follow favored in calm regimes."; return "Bearish bias detected: mean-reversion opportunity in high volatility."; }, [signal]);

return ( <div className="min-h-screen w-full bg-neutral-950 text-neutral-100 p-4 sm:p-6"> <audio ref={audioRef} src={beepData} preload="auto" /> <div className="max-w-6xl mx-auto grid gap-4"> <header className="flex flex-col sm:flex-row sm:items-end sm:justify-between gap-3"> <div> <h1 className="text-2xl sm:text-3xl font-bold tracking-tight">Fortune Gems Signal Bot</h1> <p className="text-sm text-neutral-400 mt-1">Client-side analyzer for practice. Enter recent outcomes as L/M/H or 0â€“100. No hacks, no guarantees.</p> </div> <div className="flex flex-wrap items-center gap-2"> <button onClick={() => setAutoMode((v) => !v)} className={px-3 py-2 rounded-2xl text-sm shadow ${autoMode ? "bg-emerald-600" : "bg-neutral-800"}}>{autoMode ? "Auto: ON" : "Auto: OFF"}</button> <button onClick={resetAll} className="px-3 py-2 rounded-2xl text-sm shadow bg-neutral-800">Reset</button> </div> </header>

{/* Controls */}
    <section className="grid md:grid-cols-3 gap-4">
      <div className="md:col-span-2 bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4 shadow">
        <h2 className="font-semibold mb-2">Add Outcomes</h2>
        <div className="flex flex-wrap gap-2 mb-3">
          {(["L","M","H"]).map((b) => (
            <button key={b} onClick={() => addQuick(b)} className="px-3 py-2 rounded-2xl bg-neutral-800 text-sm shadow">{b}</button>
          ))}
        </div>
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Paste values like: L M H 35 60 80 L H...\n(Separated by space/comma/newline)"
          className="w-full h-28 rounded-xl bg-neutral-800/70 border border-neutral-700 p-3 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-600"
        />
        <div className="mt-2 flex gap-2">
          <button onClick={addEntriesFromText} className="px-3 py-2 rounded-2xl bg-emerald-600 text-sm font-medium shadow">Add</button>
          <button onClick={() => setHistory((h) => h.slice(0, -1))} className="px-3 py-2 rounded-2xl bg-neutral-800 text-sm shadow">Undo</button>
        </div>
      </div>

      <div className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4 shadow">
        <h2 className="font-semibold mb-2">Settings</h2>
        <label className="block text-sm text-neutral-400 mb-1">Bucket map (L/M/H â†’ 0â€“100)</label>
        <div className="grid grid-cols-3 gap-2 mb-3">
          {["L","M","H"].map((k) => (
            <div key={k} className="bg-neutral-800 rounded-xl p-2">
              <div className="text-xs mb-1">{k}</div>
              <input type="number" className="w-full bg-neutral-900 rounded-lg p-2 text-sm"
                value={bucketMap[k]}
                onChange={(e) => setBucketMap({ ...bucketMap, [k]: clamp(Number(e.target.value||0),0,100) })}
              />
            </div>
          ))}
        </div>
        <div className="grid grid-cols-2 gap-3">
          <div>
            <label className="block text-sm text-neutral-400 mb-1">Bankroll</label>
            <input type="number" value={bankroll} onChange={(e)=> setBankroll(Math.max(0, Number(e.target.value||0)))} className="w-full bg-neutral-800 rounded-xl p-2" />
          </div>
          <div>
            <label className="block text-sm text-neutral-400 mb-1">Max % per bet</label>
            <input type="number" value={risk} onChange={(e)=> setRisk(clamp(Number(e.target.value||0), 0.2, 10))} className="w-full bg-neutral-800 rounded-xl p-2" />
          </div>
        </div>
        <div className="mt-3 flex items-center gap-2">
          <input id="sound" type="checkbox" checked={sound} onChange={(e)=> setSound(e.target.checked)} />
          <label htmlFor="sound" className="text-sm">Sound alerts</label>
        </div>
      </div>
    </section>

    {/* Signal Card */}
    <section className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4 shadow">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <div>
          <div className="text-xs uppercase tracking-wide text-neutral-400">Live Signal</div>
          <div className="text-lg sm:text-xl font-bold">{signal ? signal.action : "Waiting for data..."}</div>
        </div>
        <div className="flex gap-3 text-sm">
          <div className="bg-neutral-800 rounded-xl p-2">
            <div className="text-neutral-400 text-xs">Confidence</div>
            <div className="font-semibold">{signal ? signal.confidence + "%" : "â€”"}</div>
          </div>
          <div className="bg-neutral-800 rounded-xl p-2">
            <div className="text-neutral-400 text-xs">Suggest Size</div>
            <div className="font-semibold">{signal ? signal.suggestedPct + "%" : "â€”"}</div>
          </div>
          <div className="bg-neutral-800 rounded-xl p-2">
            <div className="text-neutral-400 text-xs">Session Stop</div>
            <div className="font-semibold">{signal ? signal.stopLossSession : "â€”"}</div>
          </div>
        </div>
      </div>

      <div className="mt-3 text-sm text-neutral-300">{tip}</div>
      <div className="mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2 text-xs text-neutral-400">
        <div className="bg-neutral-800 rounded-xl p-2">Last: <span className="text-neutral-200">{latest ?? "â€”"}</span></div>
        <div className="bg-neutral-800 rounded-xl p-2">Mean: <span className="text-neutral-200">{mean?.toFixed(2) ?? "â€”"}</span></div>
        <div className="bg-neutral-800 rounded-xl p-2">Vol: <span className="text-neutral-200">{vol?.toFixed(2) ?? "â€”"}</span></div>
        <div className="bg-neutral-800 rounded-xl p-2">Z: <span className="text-neutral-200">{signal?.context.z ?? "â€”"}</span></div>
      </div>
    </section>

    {/* Charts (minimal) */}
    <section className="grid md:grid-cols-3 gap-4">
      <div className="md:col-span-2 bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4">
        <h3 className="font-semibold mb-2">Recent History (last {last50.length})</h3>
        <Sparkline data={last50} />
      </div>
      <div className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4">
        <h3 className="font-semibold mb-2">How to Use</h3>
        <ul className="text-sm list-disc pl-5 space-y-2 text-neutral-300">
          <li>Feed your last 20â€“50 round outcomes as L/M/H or 0â€“100 strength.</li>
          <li>Wait for a clear signal (&gt; 60% confidence) before acting.</li>
          <li>Respect the suggested size cap and the session stop.</li>
          <li>For education/testing only. Outcomes are independent; no guaranteed edge.</li>
        </ul>
      </div>
    </section>

    {/* Log */}
    <section className="bg-neutral-900/60 border border-neutral-800 rounded-2xl p-4">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold">Signal Log</h3>
        <div className="text-xs text-neutral-400">{formatTime()}</div>
      </div>
      <div className="mt-2 max-h-64 overflow-auto rounded-xl border border-neutral-800">
        <table className="w-full text-sm">
          <thead className="bg-neutral-900/80 sticky top-0">
            <tr>
              <th className="text-left p-2">Time</th>
              <th className="text-left p-2">Action</th>
              <th className="text-left p-2">Conf</th>
              <th className="text-left p-2">Size %</th>
              <th className="text-left p-2">Z</th>
              <th className="text-left p-2">Vol</th>
              <th className="text-left p-2">Mean</th>
              <th className="text-left p-2">Last</th>
            </tr>
          </thead>
          <tbody>
            {log.map((row, i) => (
              <tr key={i} className="odd:bg-neutral-900/40">
                <td className="p-2 text-neutral-400">{new Date(row.t).toLocaleTimeString()}</td>
                <td className="p-2 font-semibold">{row.action}</td>
                <td className="p-2">{row.confidence}%</td>
                <td className="p-2">{row.pct}%</td>
                <td className="p-2">{row.ctx.z}</td>
                <td className="p-2">{row.ctx.vol}</td>
                <td className="p-2">{row.mean}</td>
                <td className="p-2">{row.last}</td>
              </tr>
            ))}
            {!log.length && (
              <tr>
                <td className="p-3 text-neutral-400" colSpan={8}>No logs yet.</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </section>

    <footer className="text-center text-xs text-neutral-500 mt-2">
      Built for learning & discipline. Follow game Terms of Service. No affiliation.
    </footer>
  </div>
</div>

); }

function Sparkline({ data = [] }) { const ref = useRef(null); useEffect(() => { const canvas = ref.current; if (!canvas) return; const ctx = canvas.getContext("2d"); const w = canvas.width = canvas.clientWidth * devicePixelRatio; const h = canvas.height = 140 * devicePixelRatio; ctx.clearRect(0,0,w,h); if (!data.length) return; const min = Math.min(...data); const max = Math.max(...data); const pad = 8 * devicePixelRatio; const nx = (i) => pad + (w - pad * 2) * (i / Math.max(1, data.length - 1)); const ny = (v) => h - pad - (h - pad * 2) * ((v - min) / Math.max(1e-6, max - min));

// grid
ctx.globalAlpha = 0.25;
ctx.strokeStyle = "#555";
[0.25, 0.5, 0.75].forEach((p) => {
  const y = pad + (h - pad * 2) * p;
  ctx.beginPath();
  ctx.moveTo(pad, y);
  ctx.lineTo(w - pad, y);
  ctx.stroke();
});
ctx.globalAlpha = 1;

// line
ctx.lineWidth = 2 * devicePixelRatio;
ctx.strokeStyle = "#22c55e"; // emerald
ctx.beginPath();
ctx.moveTo(nx(0), ny(data[0]));
for (let i = 1; i < data.length; i++) ctx.lineTo(nx(i), ny(data[i]));
ctx.stroke();

// last point
const lx = nx(data.length - 1);
const ly = ny(data[data.length - 1]);
ctx.fillStyle = "#e5e7eb";
ctx.beginPath();
ctx.arc(lx, ly, 3 * devicePixelRatio, 0, Math.PI * 2);
ctx.fill();

}, [data]);

return <canvas ref={ref} className="w-full h-[140px]" />; }

